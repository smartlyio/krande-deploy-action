# IMPORTANT NOTE/WARNING!
# Do not make changes to this file, your changes will be overwritten.
#
# This file is automagically generated from:
# - .github/templates/release.yml.erb
# - Templates contained in the smartlyio/github-actions-templates repository
#
# This file can be updated by editing the template file, and running `devbox render workflows`

name: Build and release the action

on:
  push:
    branches: [master]

jobs:
  build:
    runs-on: ubuntu-18.04
    steps:
    - uses: actions/checkout@v2
    - name: "Install"
      run: |
        npm install
    - name: "Prettier"
      run: |
        npm run format-check
    - name: "Lint"
      run: |
        npm run lint
    - name: "Test"
      run: |
        npm run test
    - name: "build"
      run: |
        npm run build
        npm run pack

  test:
    runs-on: ubuntu-18.04
    steps:
    - uses: actions/checkout@v2
    - name: "Build action for test"
      run: |
        npm run all
    - run: |
        # Mock the krane executable
        echo '#!/usr/bin/env bash' > ./krane.sh
        echo 'echo "$@"' >> ./krane.sh
        chmod u+x ./krane.sh
        # Make a dummy template directory
        mkdir ./templates
        echo 'kind: Service' > ./templates/manifest.yml
        echo 'kind: Deployment' > ./templates/template.yml.erb
        touch ./templates/secrets.ejson
    - name: Test rendering only
      uses: ./
      env:
        KRANE_BINDING_binding2: value2
      with:
        currentSha: ${{ github.sha }}
        dockerRegistry: testRegistry
        kubernetesClusterDomain: cluster.example.com
        kubernetesContext: testContext
        kubernetesNamespace: testNamespace
        kubernetesTemplateDir: ./templates
        kranePath: ./krane.sh
        renderOnly: true
        extraBindings: |
          {
            "deployer": "user"
          }
    - name: Test render and deploy
      uses: ./
      env:
        KRANE_BINDING_binding2: value2
      with:
        currentSha: ${{ github.sha }}
        dockerRegistry: testRegistry
        kubernetesClusterDomain: cluster.example.com
        kubernetesContext: testContext
        kubernetesNamespace: testNamespace
        kubernetesTemplateDir: ./templates
        kranePath: ./krane.sh
        deployTimeout: 30s
        extraBindings: |
          {
            "deployer": "user"
          }

  release:
    runs-on: ubuntu-18.04
    name: "Build and release action"
    needs: [build, test]
    steps:
      - uses: actions/checkout@v2
        with:
          fetch-depth: 0
      - name: build for release
        id: build
        run: |
          npm run all
          git_changes="$(git status --porcelain -- dist || true)"
            git add dist
            echo ::set-output name=has_changes::true
          else
            echo ::set-output name=has_changes::false
          fi
      - name: Get git base branch
        id: get_base_branch
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          BASE_BRANCH="$(gh api "repos/$GITHUB_REPOSITORY" | jq -r .default_branch)"
          echo ::set-output name=git_base_branch::"$BASE_BRANCH"
          echo GIT_BASE_BRANCH="$BASE_BRANCH" >> "$GITHUB_ENV"
      - name: Calculate PR filters
        id: filters
        run: |
          last_tag_date=$(git log -1 --tags --no-walk --pretty="format:%cI")
          start_date=$(date -Is -d "$last_tag_date")
          echo ::set-output name=start_date::"$start_date"
      - name: Get PR labels
        uses: octokit/graphql-action@v2.x
        id: get_latest_prs
        with:
          query: |
            query($filter:String!) {
              search(query:$filter, type: ISSUE, last: 100) {
                edges {
                  node {
                    ... on PullRequest {
                      number
                      mergedAt
                      labels (first: 100) {
                        nodes {
                          name
                        }
                      }
                    }
                  }
                }
              }
            }
          filter: repo:${{ github.repository }} is:pr base:${{ steps.get_base_branch.outputs.git_base_branch }} merged:>${{ steps.filters.outputs.start_date }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Get version being bumped
        id: version_check
        run: |
          pr_data=$(echo "${{ steps.get_latest_prs.outputs.data }}")
          echo "$pr_data"
          version=$(echo "$pr_data" | grep -m1 -oi major || echo "$pr_data" | grep -m1 -oi minor || echo "$pr_data" | grep -m1 -oi patch || echo "")
          version_lower=${version,,}
          echo ::set-output name=version::"$version_lower"
          if [ -z "$version" ]; then
            echo ::set-output name=continue_release::false
          else
            echo ::set-output name=continue_release::true
          fi
      - name: Show version being bumped
        if: steps.version_check.outputs.continue_release == 'true'
        run: echo "Based on tags, we're updating ${{ steps.version_check.outputs.VERSION }} version!"
      - name: Check if at head of branch
        id: check_branch_behind
        run: |
          git fetch --depth=1 origin ${{ github.head_ref }}
          local=${{ github.event.pull_request.head.sha }}
          remote=$(git rev-parse origin/${{ github.head_ref }})
          echo "$remote"
          if [ "$local" == "$remote" ]; then
            echo "Looks like we're at the head of the branch."
            echo ::set-output name=BRANCH_UP_TO_DATE::true
          else
            echo "Local branch is not up to date with remote. Exiting."
            echo ::set-output name=BRANCH_UP_TO_DATE::false
          fi
      - name: Tag release
        if: steps.check_branch_behind.outputs.BRANCH_UP_TO_DATE=='true' && steps.version_check.continue_release=='true'
        run: |
          npm version ${{ steps.version_check.outputs.version }}
      - name: Commit changes without tag
        if: steps.check_branch_behind.outputs.BRANCH_UP_TO_DATE=='true' && steps.version_check.continue_release=='false' && steps.build.outputs.has_changes=='true'
        run: |
          git commit -m "Update compiled action"
      - name: Push changes to master
        if: steps.check_branch_behind.outputs.BRANCH_UP_TO_DATE=='true'
        run: |
          git push && git push --tags
      - name: Update release branch
        if: steps.check_branch_behind.outputs.BRANCH_UP_TO_DATE=='true' && steps.version_check.continue_release=='true'
        run: |
          package_version="$(jq -r .version < package.json)"
          release_branch="v${package_version//.*/}"
          upstream="origin/${release_branch}"

          git checkout -b "${release_branch}"
          git branch --set-upstream-to="${upstream}"

          git push origin "${release_branch}"
